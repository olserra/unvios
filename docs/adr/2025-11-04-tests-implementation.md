# ADR 0004 — Tests Implementation

Date: 2025-11-04T00:00:00Z

Status: Accepted

## Context

This project previously had no unit test scripts configured in `package.json`. There is an existing Playwright configuration for e2e tests (`playwright.config.ts`) but Playwright was not installed. To reduce risk when changing prompt construction, memory parsing, and DB query logic, we added a small, focused unit test suite and related developer ergonomics.

## Decision

- Use Vitest as the unit test runner for fast, TypeScript-friendly tests.
- Add minimal unit tests that exercise pure logic only (avoid importing Next.js route modules that pull in DB/auth at top-level).
- Extract a small, focused parser into `lib/memoryParser.ts` so parsing logic can be tested without initializing the full server route.

Files added/modified:

- `package.json` — added test scripts:
  - `test`: `vitest`
  - `test:watch`: `vitest --watch`
- `lib/memoryParser.ts` — added: `parseMemories(output: string)`
- `tests/memoryParser.test.ts` — unit tests for memory parsing (happy path and edge cases)
- `tests/utils.test.ts` — unit tests for `lib/utils.ts` safeStorage helpers
- `app/api/llm/chat/route.ts` — refactored to import `parseMemories` from `lib/memoryParser` and keep route behavior unchanged.

## Rationale

- Vitest is lightweight, fast, and integrates well with TypeScript. It is a good fit for unit tests and developer feedback loops.
- Extracting pure logic into small modules (for example `lib/memoryParser.ts`) avoids the need to mock or initialize heavy server-side dependencies when running unit tests.
- Start with a small set of tests that provide high value and low maintenance overhead (parsing, storage helpers); grow coverage iteratively.

## How to run tests

From the project root (zsh):

```bash
pnpm install # if dev dependencies not yet installed
pnpm test
# or watch mode
pnpm test:watch
```

Vitest will run the `tests/` directory files. Newly added tests include

- `tests/memoryParser.test.ts` — ensures the parser extracts memory annotations like `[MEMORY: <content> | tag1, tag2]` correctly and covers edge cases (whitespace, malformed markers, tag limits).
- `tests/utils.test.ts` — validates the `safeStorage` helpers in `lib/utils.ts`.

## Quality gates and suggestions

- Add a minimal GitHub Actions workflow to run `pnpm install` and `pnpm test` on push and pull requests.
- When testing modules that interact with the DB or external services (embeddings/LLM), prefer mocking those dependencies (Vitest `vi.mock`) rather than initializing real services.
- Add tests for the following next:
  - `buildPromptFromMemories` (pure prompt-construction logic)
  - `lib/db/queries.ts` — where possible, test pure query builders and use integration tests with a test Postgres instance for SQL correctness
  - Route-level tests with mocked auth/session and DB client (use `vi.mock` to stub `getSession`, `getUser`, and `db`/`client`)

## Consequences

Positive:

- Immediate regression protection for memory parsing and storage helpers.
- Faster developer feedback loop when editing core logic.

Trade-offs:

- Initial test surface is small — more tests will be needed for complete coverage.
- Tests that need DB/LLM integration will require additional setup (local test DB or CI service, plus network stubbing).

## Next steps

1. Add a GitHub Actions workflow to run tests on PRs.
2. Expand unit tests to cover prompt building and more utility modules.
3. Add examples for mocking `getSession` / DB calls in route tests.

---

Generated by development tooling on 2025-11-04.
